# Github
> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)

- [Article](#article)
- [Repository](#repository)
- [Organization](#organization)
- [Interaction](#interaction)
- [Task](#task)

## Article
```mermaid
erDiagram
"Article" {
  String id PK
  String last_snapshot_id "nullable"
  DateTime created_at
  DateTime deleted_at
}
"Comment" {
  String id PK
  String article_id FK
  String writer_id FK
  String parent_id FK "nullable"
}
"CommentSnapshot" {
  String id PK
  String comment_id FK
  String format
  String body
  DateTime created_at
}
"ArticleLastSnapshot" {
  String article_id PK
  String article_snapshot_id FK
}
"ArticleSnapshot" {
  String id PK
  String article_id FK
  String title
  String format
  String body
  DateTime created_at
}
"ArticleAttachmentFile" {
  String id PK
  String article_snapshot_id FK
  String original_url
  DateTime created_at
}
"Comment" }o--|| "Article" : Article
"Comment" }o--o| "Comment" : Parent
"CommentSnapshot" }o--|| "Comment" : Comment
"ArticleLastSnapshot" |o--|| "Article" : Article
"ArticleLastSnapshot" |o--|| "ArticleSnapshot" : Snapshot
"ArticleSnapshot" }o--|| "Article" : Article
"ArticleAttachmentFile" }o--|| "ArticleSnapshot" : ArticleSnapshot
```

### `Article`
게시글

모든 게시글의 원형으로서 게시글의 Base가 된다.
예컨대, Github의 issue, pull_request 등은 Article의 일종이다.
이런 경우 Article을 Base로 가지는 테이블이 될 것이며, 해당 테이블들은 Article의 ID를 가지기만 해도,
게시글과 같이 글을 작성하고 수정하는 모든 기능이 ERD 상 완성된 것으로 볼 수 있게 되는 것이다.

**Properties**
  - `id`: ID
  - `last_snapshot_id`
    > 마지막 스냅샷 아이디
    > 
    > 마지막 스냅샷으로 바로 갈 수 있도록 아이디를 하나 더 걸어둔다.
    > 의도된 반 정규화이다.
  - `created_at`: 데이터가 생성된 시간
  - `deleted_at`
    > 데이터가 삭제된 시간
    > 
    > 해당 시간이 비어있으면(NULL이면) 아직 삭제가 되지 않은 것이다.

### `Comment`
댓글

모든 댓글의 Base가 된다.
댓글은 칼럼만 두고 보았을 때는 [게시글](#Article)과 거의 비슷한데, 이는 글을 쓴다는 목적이 같기 때문이다.
다만 개념 상 [게시글](#Article)과는 달리 [게시글](#Article)에 달리는 짧은 글귀라는 점에서 차이가 있으므로 별도의 테이블로 관리함이 맞다.

**Properties**
  - `id`: 
  - `article_id`
    > [게시글](#Article) 아이디 
    > 
    > [게시글](#Article) 아이디로부터 [게시글](#Article) 스냅샷을 가고, 어떤 내용인지 추적할 수 있게 된다.
  - `writer_id`
    > 작성자의 아이디
    > 
    > 이 댓글을 작성한 사람의 아이디를 의미한다.
  - `parent_id`
    > 부모 댓글의 아이디
    > 
    > 부모인 댓글이 있는 경우를 의미한다.
    > Github에서는 부모 댓글이라는 개념이 존재하지 않지만, 이 또한 추후 추가될 가능성이 있다.
    > 기존에는 없던 sub_issue 개념이 생긴 것과 같이 기획 상 변경을 대응하기 위해 미리 생성하는 칼럼이다.

### `CommentSnapshot`

**Properties**
  - `id`: ID
  - `comment_id`: [댓글](#Comment)의 아이디
  - `format`: md, html, text 중 하나를 의미한다.
  - `body`: 본문 내용
  - `created_at`
    > 데이터가 생성된 시간
    > 
    > 데이터가 생성된 시간이지만, Comment 입장에서는 수정된 시간과 같다.
    > 이 시간이 가장 마지막인, 즉 마지막 스냅샷이 현재 댓글의 내용으로 유저에게 표시된다.

### `ArticleLastSnapshot`
[게시글](#Article)의 마지막 스냅샷

성능 상 이슈를 해결하기 위해서 마지막 스냅샷에 대한 참조를 건다.
이 테이블을 이용하면 전체 스냅샷을 조회할 필요 없이 항상 마지막 스냅샷을 찾을 수 있다.
게시글을 수정, 즉 게시글 스냅샷을 추가할 때에는 항상 이 참조 값을 바꾸어야 한다.

모든 게시글은, 1:N 관계임에도 반드시 스냅샷을 가지므로 논리적으로 이 테이블의 row를 반드시 가진다.
이는 DB의 제약 조건과 무관하게, 반드시 논리적인 연결이 있음을 의미한다.

**Properties**
  - `article_id`
    > [게시글](#Article)의 아이디
    > 
    > 게시글의 아이디를 FK이자 PK로 가져, 게시글마다 1개의 row만 가진다고 명시한다.
  - `article_snapshot_id`
    > [ArticleSnapshot](#ArticleSnapshot)의 아이디
    > 
    > 스냅샷의 아이디로, 유니크 설정이 걸려 단 1개만 존재할 수 있다.
    > 이는 각 게시글마다 마지막 스냅샷으로서 걸 수 있는 스냅샷이 단 1개만 있다는 것이다.

### `ArticleSnapshot`
[게시글](#Article)의 스냅샷 목록

**Properties**
  - `id`: ID
  - `article_id`: [게시글](#Article)의 아이디
  - `title`: 제목
  - `format`: md, html, text 중 하나를 의미한다.
  - `body`: 본문 내용 
  - `created_at`
    > 데이터가 생성된 시간
    > 
    > 데이터가 생성된 시간이지만, Article 입장에서는 수정된 시간과 같다.
    > 이 시간이 가장 마지막인, 즉 마지막 스냅샷이 현재 게시글의 내용으로 유저에게 표시된다.

### `ArticleAttachmentFile`
게시글 첨부 파일

게시글에 첨부된 파일을 의미한다.
파일은 [스냅샷](#ArticleSnapshot)에 연결되며, 파일의 변경이 일어날 경우 스냅샷이 생성되어야 한다.
만약 파일의 변동이 아닌 스냅샷의 변동인 경우, 파일 내역은 그대로 다음 스냅샷으로 이어진다.

**Properties**
  - `id`: ID
  - `article_snapshot_id`: 
  - `original_url`: 파일의 URI
  - `created_at`: 


## Repository
```mermaid
erDiagram
"Owner" {
  String id PK
  String type
  String user_id FK "nullable"
  String organization_id FK "nullable"
}
"User" {
  String id PK
  String username UK
  String email
  String password
}
"Repository" {
  String id PK
  String owner_id FK
  String name
  String description "nullable"
  Boolean is_private
  String language "nullable"
  DateTime created_at
  DateTime updated_at
}
"Branch" {
  String id PK
  String commit_id FK
  String name
  Boolean is_master
  String repository_id FK
  DateTime created_at
}
"BranchFileSnapshot" {
  String id PK
  String branch_id FK
  String file_id FK
}
"Commit" {
  String id PK
  String repository_id FK
  String commiter_id FK
  String parent_id FK "nullable"
  String hash
  String message
  DateTime created_at
}
"File" {
  String id PK
  String commit_id FK "nullable"
  String name
  String extension "nullable"
  String body "nullable"
}
"Organization" {
  String id PK
  String creator_id FK
  String name UK
}
"Owner" |o--o| "User" : User
"Owner" |o--o| "Organization" : Organization
"Repository" }o--|| "Owner" : owner
"Branch" }o--|| "Repository" : Repository
"Branch" }o--|| "Commit" : Commit
"BranchFileSnapshot" }o--|| "Branch" : Branch
"BranchFileSnapshot" }o--|| "File" : File
"Commit" }o--|| "Repository" : Repository
"Commit" }o--|| "User" : User
"Commit" }o--o| "Commit" : Parent
"File" }o--o| "Commit" : Commit
"Organization" }o--|| "User" : Creator
```

### `Owner`
Owner

Github 상에서 `Owner`는 반드시 유저 마다 1개씩 존재하는 것이긴 하지만,
반드시 그것이 유저를 대상으로 한다고 말할 수는 없는 것이다.
때로는 유저가 아니라 Organization이 소유자일 수도 있다.
Owner는 논리적으로 [유저](#User)와 [조직](#Organization)에 반드시 1개가 존재한다.

**Properties**
  - `id`: ID
  - `type`
    > Type of Owner
    > 
    > Owner의 타입을 의미한다.
    > 코드 저장소에서 Owner는 반드시 개인이 아니라 Organization일 수도 있기 때문이다.
    > 유저 아이디가 null인지 아닌지로 알 수 있는 내용이긴 하지만, 별도의 타입을 두어 구분한다.
  - `user_id`
    > ID of User
    > 
    > 만약 Repository의 소유자가 개인일 경우 user_id가 존재한다.
  - `organization_id`
    > ID of Organization
    > 
    > 만약 Repository의 소유자가 집단일 경우 user_id가 존재한다.

### `User`
User

Github에서의 유저를 의미한다.
유저는 '개인' 1명을 의미하며, 레포지토리를 생성하거나 커밋을 하는 등 Github에서의 활동 주체이다.
여기서 유저는 회원가입한 사람을 의미한다.

**Properties**
  - `id`: ID
  - `username`
    > Username
    > 
    > 서비스에서의 사용자 이름
  - `email`
    > Email
    > 
    > 사용자의 이메일 주소
  - `password`
    > Password
    > 
    > Hash 알고리즘이 적용된 문자열을 의미한다.
    > 절대 평문으로 저장하지 않는다.

### `Repository`
Repository

Github의 레포지토리를 의미한다.
레포지토리는 코드 저장소를 의미하며, 하나의 레포지토리는 0개 이상의 Branch를 가진다.
Branch는 커밋의 특정 해시에 사람이 알아볼 수 있는 자연어 이름을 붙인 것인데,
엄밀히 말해 Repository는 여러 개의 Commit 이력을 가지고 있다고 말할 수 있겠다.
Commit은 링크드 리스트의 형태처럼 이어지지만, 분기가 되어 서로 다른 리스트로 이어지기도 한다.
단, 커밋 연결이 역행하여 순회를 이루거나, 하나의 커밋이 두 개 이상의 이전 커밋을 가지는 경우는 없다.

**Properties**
  - `id`: ID
  - `owner_id`
    > Owner ID
    > 
    > Repository를 소유한 Owner의 ID
  - `name`
    > Name of the Repository
    > 
    > 레포지토리의 이름
  - `description`
    > Description
    > 
    > 레포지토리 설명
  - `is_private`
    > Visibility of Repository
    > 
    > 레포지토리의 공개 여부
  - `language`
    > Primary Programming Language
    > 
    > 주요 언어
  - `created_at`
    > Created At
    > 
    > 레포지토리 생성 시간
  - `updated_at`
    > Last Updated At
    > 
    > Repository가 마지막으로 업데이트된 시간

### `Branch`
Branch

브랜치는 커밋에 사람이 인식할 수 있는 자연어 이름을 지정한 것을 의미한다.
따라서 브랜치는 어떠한 커밋에 이름을 붙였는지를 알기 위해 commit_id를 지닌다.
동일한 커밋 값에 여러 개의 브랜치를 생성하는 것 역시 가능하다.

**Properties**
  - `id`: ID
  - `commit_id`: 
  - `name`: Branch의 이름을 의미한다.
  - `is_master`
    > 마스터, 즉 메인 브랜치를 의미한다.
    > 
    > 이 칼럼이 True인 경우 Main 브랜치
  - `repository_id`: 
  - `created_at`: 데이터가 생성된 시간

### `BranchFileSnapshot`
Branch의 파일 목록

각 커밋은 커밋으로 인해 변경된 파일만을 지닌다.
따라서 특정 시점에서의 전체 파일 목록을 조회하고자 하면 그 전까지의 커밋들을 순회하는 수 밖에 없다.
실제 Git의 구현은 위와 같지만, 이를 보다 성능 상 유리하게 만들기 위해 브랜치에 한정하여 캐시를 하도록 한다.
브랜치는 해당 브랜치 이전에 만들어진 가장 최근 브랜치를 기준으로 삼아, 해당 브랜치로부터 나머지 커밋들을 순회하여 현 상태를 저장하게끔 한다.
이 캐시는 브랜치의 생성 시점을 기준으로 하며, 브랜치로부터 커밋이 추가로 생긴다면 다시금 순회를 시작해야 한다.

또한, 순회를 이용하든 일정 지점까지는 캐시를 이용하고 나머지만 순회하든, 결국 동일한 파일 목록이 나온다고 보장되어야 한다.

**Properties**
  - `id`: ID
  - `branch_id`: 캐시한 브랜치의 아이디
  - `file_id`: 캐시할 파일의 아이디를 의미한다.

### `Commit`
레포지토리 상에서의 변경 내역을 의미한다.

변경 내역은 `Commit` 이라고 하며 변경된 파일의 목록을 지닌다.
이 때, 변경 내역이 없을 수도 있는데, 이는 `Empty Commit` 이라고 하여 명시적으로 커밋한 경우이다.
이 경우를 제외하고는 `Files`는 반드시 1개 이상 존재해야 한다.

**Properties**
  - `id`: ID
  - `repository_id`: 
  - `commiter_id`: 커밋 자성자의 아이디
  - `parent_id`
    > 부모 커밋의 아이디
    > 
    > 커밋은 기본적으로 링크드리스트이며, 최초의 커밋 외에는 무조건 부모의 아이디를 가진다.
  - `hash`: 커밋을 가리킬 수 있는 Hash 값
  - `message`: 커밋 메시지
  - `created_at`: 데이터가 생성된 시간

### `File`
커밋이 변경한 파일

커밋이 변경한 파일은 body에 전체 파일 내용을 가지고 있어야 한다.
Github에서 `diff`를 보여주는 방식은 DB에 저장되는 것이 아니다.
파일의 변경 내역을 비교할 두 커밋은 무수한 조합이 가능하기 때문에 미리 DB에 저장하는 것이 불가능하다.

두 커밋을 가지고 `diff`를 구하고자 할 때, 이전 커밋이 LEFT로, 나중 커밋은 RIGHT로 지정되며 diff 알고리즘에 따른다.

**Properties**
  - `id`: ID
  - `commit_id`: 
  - `name`
    > 파일의 이름
    > 
    > 파일의 이름에는 path를 포함하고 있다.
  - `extension`
    > 파일의 확장자
    > 
    > 파일의 확장자는 파일의 이름으로부터 추출하되, 알 수 없는 경우가 있을 수도 있다.
    > 일반 텍스트 파일의 경우 `txt` 확장자이지만 그마저도 명시가 안된 경우가 있을 수 있어 null을 허용한다.
  - `body`: 파일의 내용물


## Organization
```mermaid
erDiagram
"Organization" {
  String id PK
  String creator_id FK
  String name UK
}
"Manager" {
  String id PK
  String user_id FK
  String organization_id FK
  String repository_id
  String type
}
"User" {
  String id PK
  String username UK
  String email
  String password
}
"Organization" }o--|| "User" : Creator
"Manager" }o--|| "User" : User
"Manager" }o--|| "Organization" : Organization
```

### `Organization`
Organization

조직을 의미한다.
Github 상에서 조직은 [유저](#User)와 마찬가지로 [코드 저장소](#Repository) 여러 개를 갖는 소유 단위이다.
조직에는 여러 [유저](#User)가 각기 다른 권한으로 속할 수 있되, 최초 생성자는 무조건 소유자 권한을 가진다.
각 권한이 무엇이 있는지는 [매니저](#Manager) 테이블을 참고하라.

**Properties**
  - `id`: ID
  - `creator_id`
    > Creator ID
    > 
    > 최초로 이 Organization을 만든 사람의 아이디를 의미한다.
    > 이 아이디가 있다고 해서, 이 사람만이 조직을 운영할 수 있는 것은 아니다.
  - `name`
    > name
    > 
    > 서비스에서의 조직 이름

### `Manager`
조직을 관리할 수 있는 매니저

Github에서는 하나의 조직을, 생성한 Owner 외에도 관리할 수 있을 뿐더러, Owner 를 다수로 지정할 수도 있다.
다수의 관리자들을 두는 경우, 여기서 Organization의 아이디와 User의 ID를 매핑하면 된다.
어떠한 권한들이 존재하는지는 `type` 칼럼의 주석을 참고하자.

하나의 [조직](#Organization), 하나의 [코드 저장소](#Repository)에는 동일한 유저는 1번씩만 매니저로 등록될 수 있다.

**Properties**
  - `id`: ID
  - `user_id`
    > User ID
    > 
    > 매니저로 지정될 유저의 아이디
  - `organization_id`
    > Organization ID 
    > 
    > 매니저가 지정될 조직의 아이디
  - `repository_id`
    > Organization ID 
    > 
    > 매니저가 지정될 조직의 아이디
  - `type`
    > 매니저의 권한
    > 
    > 매니저의 경우, Owner, Admin, Write, Read가 존재한다.
    > - Owner: 리포지토리의 모든 설정을 관리할 수 있는 권한으로 삭제 및 이동, 타 멤버의 권한을 조정하는 행위가 가능
    > - Admin: 레포지토리 설정을 관리할 수 있음
    > - Write: 레포지토리에 `Push`가 가능하다.
    > - Read: 코드를 읽을 수 있을 뿐, 코드 작성 뿐만 아니라 이슈나 PR 등의 생성 역시 불가능하다.
    > 
    > 단, Repository에 대해서는 소유자 외 다른 사람을 `Owner` 권한으로 할당할 수 없다.


## Interaction
```mermaid
erDiagram
"Star" {
  String id PK
}
"Base" {
  String id PK
  String repository_id FK
  String user_id FK
  DateTime created_at
}
"Fork" {
  String id PK
}
"Star" |o--|| "Base" : Base
"Fork" |o--|| "Base" : Base
```

### `Star`
Star

사용자가 레포지토리에 별점을 준 기록

**Properties**
  - `id`: ID

### `Base`
상호작용을 의미한다.

여기서의 상호작용은 코드 저장소인 Repository와 유저 사이의 상호작용이다.
스타를 누르거나 포크를 하는 등의 모든 상호작용을 Interaction이라고 하는데,
굳이 이를 Base Entity로 뺀 이유는 추후 어떠한 확장 요소가 생길지 모르기 때문이다.
이러한 확장성을 제외하고 생각한다면 Interaction에 type 칼럼을 두고 'star', 'fork'로 구분하는 것도 나쁘지 않다.

추후 사라질 수 있는 테이블이며, 이 경우 'fork'가 다른 방식으로 구현될 여지가 있기 때문이다.

**Properties**
  - `id`: ID
  - `repository_id`
    > Repository ID
    > 
    > 레포지토리의 ID
  - `user_id`
    > User ID
    > 
    > 사용자의 ID
  - `created_at`: 데이터가 생성된 시간

### `Fork`
Fork

사용자가 레포지토리를 포크한 기록

**Properties**
  - `id`: ID


## Task
```mermaid
erDiagram
"Issue" {
  String article_id PK
  String user_id FK
}
"Assignee" {
  String id PK
  String issue_id FK
  String user_id FK
}
"PullRequest" {
  String article_id PK
  String user_id FK
  String source_id FK
  String target_id FK
  String status
}
"Reviewer" {
  String id PK
  String pull_request_id FK
  String user_id FK
}
"Task" {
  String article_id PK
  String user_id FK
  Int number
}
"Article" {
  String id PK
  String last_snapshot_id "nullable"
  DateTime created_at
  DateTime deleted_at
}
"Branch" {
  String id PK
  String commit_id FK
  String name
  Boolean is_master
  String repository_id FK
  DateTime created_at
}
"Issue" |o--|| "Task" : Task
"Assignee" }o--|| "Issue" : Issue
"PullRequest" |o--|| "Task" : Task
"PullRequest" }o--|| "Branch" : Source
"PullRequest" }o--|| "Branch" : Target
"Reviewer" }o--|| "PullRequest" : PullRequest
"Task" |o--|| "Article" : Article
```

### `Issue`
Issue

저장소에 작성한 이슈를 의미한다.
저장소의 이슈는 다른 작성자가 질문이나 버그 등 개발자에게 문제를 제기할 때 사용한다.
단순히 질문 용도로도 사용할 수 있으나, 이는 Owner가 명시한 내용에 맞춰 작성하는 것이 일반적이다.

**Properties**
  - `article_id`: 게시글 아이디로, 이 아이디를 통해서 이슈의 내용을 확인할 수 있다.
  - `user_id`: 이슈를 작성한 사람의 아이디

### `Assignee`
담당자 관계를 의미한다.

담당자를 가리키기 위한 관계 테이블이다.

**Properties**
  - `id`: 담당자의 아이디로, 유저의 아이디와 무관하게 담당 지정을 가리키기 위한 용도의 아이디
  - `issue_id`: 담당자로 정한 이슈
  - `user_id`
    > 담당해주길 원하는 사람의 아이디
    > 
    > 담당를 한다는 것은 최소한 이 사람의 권한이 Write 권한이라는 의미이다.
    > 이 때, 권한은 Organization, Repository에 따라 다를 수 있다.

### `PullRequest`
PR 혹은 Pull Request

어떤 커밋을 반영하고자 할 때, 개발자는 반영 요청을 하는데 이를 PR이라고 한다.
PR은 반영을 원하는 브랜치로부터 다른 브랜치 이름을 가리킨다.
브랜치는 커밋에 이름을 붙인, 일종의 변수명에 해당하지만,
그럼에도 PR에서는 커밋이 아닌 브랜치를 기준으로 해야 한다.

**Properties**
  - `article_id`: 게시글 아이디로, 이 아이디를 통해서 이슈의 내용을 확인할 수 있다.
  - `user_id`: 이슈를 작성한 사람의 아이디
  - `source_id`: 소스 브랜치의 아이디
  - `target_id`: 타겟 브랜치의 아이디
  - `status`
    > PR의 상태
    > 
    > It must be one of: 'opened', 'closed', 'merged'
    > 논리적으로 하나의 source 브랜치로부터 다른 target 브랜치로의 PR은 1개만 존재 가능하다.
    > 따라서, 이미 열려있는 PR이 있는 경우 동일한 두 브랜치 사이 새로운 PR은 생성 불가하다.

### `Reviewer`
리뷰어 관계를 의미한다.

리뷰어를 가리키기 위한 관계 테이블이다.

**Properties**
  - `id`: 리뷰어의 아이디로, 유저의 아이디와 무관하게 리뷰 지정을 가리키기 위한 용도의 아이디
  - `pull_request_id`: 리뷰를 요청받은 PR의 아이디
  - `user_id`
    > 리뷰해주길 원하는 사람의 아이디
    > 
    > 리뷰를 한다는 것은 최소한 이 사람의 권한이 Write 권한이라는 의미이다.
    > 이 때, 권한은 Organization, Repository에 따라 다를 수 있다.

### `Task`

**Properties**
  - `article_id`: 게시글의 아이디
  - `user_id`: 작성자의 아이디
  - `number`
    > 태스크 넘버
    > 
    > 가리킬 수 있는 자연수 값으로, 1부터 시작한다.
    > 이슈나 PR을 작성할 때 # 기호 뒤에 숫자를 붙임으로써 이슈나 PR을 가리킬 수 있다.